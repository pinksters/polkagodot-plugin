<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
        <title>$GODOT_PROJECT_NAME</title>
        <style>
html, body, #canvas {
    margin: 0;
    padding: 0;
    border: 0;
}

body {
    color: white;
    background-color: black;
    overflow: hidden;
    touch-action: none;
}

#canvas {
    display: block;
}

#canvas:focus {
    outline: none;
}

#status, #status-splash, #status-progress {
    position: absolute;
    left: 0;
    right: 0;
}

#status, #status-splash {
    top: 0;
    bottom: 0;
}

#status {
    background-color: #242424;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    visibility: hidden;
}

#status-splash {
    max-height: 100%;
    max-width: 100%;
    margin: auto;
}

#status-progress, #status-notice {
    display: none;
}

#status-progress {
    bottom: 10%;
    width: 50%;
    margin: 0 auto;
}

#status-notice {
    background-color: #5b3943;
    border-radius: 0.5rem;
    border: 1px solid #9b3943;
    color: #e0e0e0;
    font-family: 'Noto Sans', 'Droid Sans', Arial, sans-serif;
    line-height: 1.3;
    margin: 0 2rem;
    overflow: hidden;
    padding: 1rem;
    text-align: center;
    z-index: 1;
}
        </style>
        $GODOT_HEAD_INCLUDE
    </head>
    <body>
        <canvas id="canvas">
            Your browser does not support the canvas tag.
        </canvas>

        <noscript>
            Your browser does not support JavaScript.
        </noscript>

        <div id="status">
            <img id="status-splash" src="$GODOT_SPLASH" alt="">
            <progress id="status-progress"></progress>
            <div id="status-notice"></div>
        </div>

        <script src="$GODOT_URL"></script>
        <script>
        const GODOT_CONFIG = $GODOT_CONFIG;
        const GODOT_THREADS_ENABLED = $GODOT_THREADS_ENABLED;
        const engine = new Engine(GODOT_CONFIG);

        (function () {
            const statusOverlay = document.getElementById('status');
            const statusProgress = document.getElementById('status-progress');
            const statusNotice = document.getElementById('status-notice');

            let initializing = true;
            let statusMode = '';

            function setStatusMode(mode) {
                if (statusMode === mode || !initializing) {
                    return;
                }
                if (mode === 'hidden') {
                    statusOverlay.remove();
                    initializing = false;
                    return;
                }
                statusOverlay.style.visibility = 'visible';
                statusProgress.style.display = mode === 'progress' ? 'block' : 'none';
                statusNotice.style.display = mode === 'notice' ? 'block' : 'none';
                statusMode = mode;
            }

            function setStatusNotice(text) {
                while (statusNotice.lastChild) {
                    statusNotice.removeChild(statusNotice.lastChild);
                }
                const lines = text.split('\n');
                lines.forEach((line) => {
                    statusNotice.appendChild(document.createTextNode(line));
                    statusNotice.appendChild(document.createElement('br'));
                });
            }

            function displayFailureNotice(err) {
                console.error(err);
                if (err instanceof Error) {
                    setStatusNotice(err.message);
                } else if (typeof err === 'string') {
                    setStatusNotice(err);
                } else {
                    setStatusNotice('An unknown error occured');
                }
                setStatusMode('notice');
                initializing = false;
            }

            const missing = Engine.getMissingFeatures({
                threads: GODOT_THREADS_ENABLED,
            });

            if (missing.length !== 0) {
                if (GODOT_CONFIG['serviceWorker'] && GODOT_CONFIG['ensureCrossOriginIsolationHeaders'] && 'serviceWorker' in navigator) {
                    // There's a chance that installing the service worker would fix the issue
                    Promise.race([
                        navigator.serviceWorker.getRegistration().then((registration) => {
                            if (registration != null) {
                                return Promise.reject(new Error('Service worker already exists.'));
                            }
                            return registration;
                        }).then(() => engine.installServiceWorker()),
                        // For some reason, `getRegistration()` can stall
                        new Promise((resolve) => {
                            setTimeout(() => resolve(), 2000);
                        }),
                    ]).catch((err) => {
                        console.error('Error while registering service worker:', err);
                    }).then(() => {
                        window.location.reload();
                    });
                } else {
                    // Display the message as usual
                    const missingMsg = 'Error\nThe following features required to run Godot projects on the Web are missing:\n';
                    displayFailureNotice(missingMsg + missing.join('\n'));
                }
            } else {
                setStatusMode('progress');
                engine.startGame({
                    'onProgress': function (current, total) {
                        if (current > 0 && total > 0) {
                            statusProgress.value = current;
                            statusProgress.max = total;
                        } else {
                            statusProgress.removeAttribute('value');
                            statusProgress.removeAttribute('max');
                        }
                    },
                }).then(() => {
                    setStatusMode('hidden');
                }, displayFailureNotice);
            }
        }());


        // ABI encoder/decoder for ERC721 contract calls
        const ABIEncoder = {
            // Precomputed function selectors
            selectors: {
                'ownerOf': '0x6352211e',         // ownerOf(uint256)
                'tokenURI': '0xc87b56dd',        // tokenURI(uint256)
                'totalSupply': '0x18160ddd',     // totalSupply()
                'name': '0x06fdde03',            // name()
                'symbol': '0x95d89b41'           // symbol()
            },

            encodeAddress(address) {
                return address.slice(2).toLowerCase().padStart(64, '0');
            },

            encodeUint256(value) {
                const hex = BigInt(value).toString(16);
                return hex.padStart(64, '0');
            },

            decodeAddress(data) {
                if (!data || data === '0x') return null;
                return '0x' + data.slice(-40).toLowerCase();
            },

            decodeUint256(data) {
                if (!data || data === '0x') return 0;
                // Remove '0x' prefix if present
                const hex = data.startsWith('0x') ? data.slice(2) : data;
                // Use BigInt for proper uint256 handling, then convert to number
                // This is safe for NFT balances which are typically small
                const bigIntValue = BigInt('0x' + hex);
                return Number(bigIntValue);
            },

            decodeString(data) {
                if (!data || data === '0x' || data.length < 130) return '';
                const strData = data.slice(130);
                const length = parseInt(data.slice(66, 130), 16) * 2;
                const hexStr = strData.slice(0, length);
                let str = '';
                for (let i = 0; i < hexStr.length; i += 2) {
                    const code = parseInt(hexStr.substr(i, 2), 16);
                    if (code !== 0) str += String.fromCharCode(code);
                }
                return str;
            },

            buildCallData(functionName, ...params) {
                const selector = this.selectors[functionName];
                if (!selector) throw new Error('Unknown function: ' + functionName);
                return selector + params.join('');
            }
        };

        const WalletManager = {
            discoveredWallets: new Map(),
            provider: null,
            currentAddress: null,
            currentWalletId: null,
            availableAccounts: [],

            init() {
                this.setupEIP6963Discovery();
                this.checkLegacyProviders();
            },

            setupEIP6963Discovery() {
                if (typeof window === 'undefined') return;

                window.addEventListener("eip6963:announceProvider", (event) => {
                    const detail = event.detail;
                    if (detail && detail.info && detail.provider) {
                        const walletId = detail.info.uuid || detail.info.name;
                        this.discoveredWallets.set(walletId, {
                            info: detail.info,
                            provider: detail.provider
                        });
                        console.log(`[PolkaInterface] Discovered wallet: ${detail.info.name} (${walletId})`);
                    }
                });

                window.dispatchEvent(new Event("eip6963:requestProvider"));
            },

            checkLegacyProviders() {
                setTimeout(() => {
                    if (window.ethereum && this.discoveredWallets.size === 0) {
                        const legacyId = 'legacy-ethereum';
                        let name = 'Unknown Wallet';
                        let icon = '';

                        if (window.ethereum.isMetaMask) {
                            name = 'MetaMask';
                        } else if (window.ethereum.isCoinbaseWallet) {
                            name = 'Coinbase Wallet';
                        } else if (window.ethereum.isBraveWallet) {
                            name = 'Brave Wallet';
                        }

                        this.discoveredWallets.set(legacyId, {
                            info: {
                                uuid: legacyId,
                                name: name,
                                icon: icon,
                                rdns: 'legacy.ethereum'
                            },
                            provider: window.ethereum
                        });
                        console.log(`[PolkaInterface] Discovered legacy wallet: ${name}`);
                    }
                }, 100);
            },

            getDiscoveredWallets() {
                const wallets = [];
                for (const [id, wallet] of this.discoveredWallets) {
                    wallets.push({
                        id: id,
                        name: wallet.info.name,
                        icon: wallet.info.icon,
                        rdns: wallet.info.rdns
                    });
                }
                return wallets;
            },

            async getAccountsForWallet(walletId) {
                const wallet = this.discoveredWallets.get(walletId);
                if (!wallet) {
                    throw new Error('Wallet not found: ' + walletId);
                }

                try {
                    const accounts = await wallet.provider.request({
                        method: 'eth_accounts'
                    });
                    return accounts || [];
                } catch (error) {
                    console.error('Error getting accounts:', error);
                    return [];
                }
            },

            async connectWallet(walletId = null) {
                try {
                    if (walletId) {
                        const wallet = this.discoveredWallets.get(walletId);
                        if (!wallet) {
                            throw new Error('Wallet not found: ' + walletId);
                        }
                        this.provider = wallet.provider;
                        this.currentWalletId = walletId;
                    } else if (this.discoveredWallets.size > 0) {
                        const firstWallet = this.discoveredWallets.entries().next().value;
                        this.provider = firstWallet[1].provider;
                        this.currentWalletId = firstWallet[0];
                    } else if (window.ethereum) {
                        this.provider = window.ethereum;
                        this.currentWalletId = 'legacy-ethereum';
                    } else {
                        console.error('No Ethereum provider detected');
                        return false;
                    }

                    const accounts = await this.provider.request({
                        method: 'eth_requestAccounts'
                    });
                    this.availableAccounts = accounts || [];
                    this.currentAddress = accounts[0];
                    return true;
                } catch (error) {
                    console.error('Error connecting wallet:', error);
                    return false;
                }
            },

            async requestAccountSelection() {
                if (!this.provider) {
                    throw new Error('No wallet connected');
                }

                try {
                    if (this.provider.request) {
                        try {
                            await this.provider.request({
                                method: 'wallet_requestPermissions',
                                params: [{
                                    eth_accounts: {}
                                }]
                            });
                        } catch (permError) {
                            console.log('wallet_requestPermissions not supported, using eth_requestAccounts');
                        }

                        const accounts = await this.provider.request({
                            method: 'eth_requestAccounts'
                        });

                        this.availableAccounts = accounts || [];
                        if (accounts && accounts.length > 0) {
                            this.currentAddress = accounts[0];
                        }

                        return accounts || [];
                    }
                } catch (error) {
                    console.error('Error requesting account selection:', error);
                    throw error;
                }
            },

            async selectAccount(address) {
                if (this.availableAccounts.includes(address)) {
                    this.currentAddress = address;
                    return true;
                }
                return false;
            },

            async signMessage(message) {
                if (!this.provider || !this.currentAddress) {
                    console.error('Wallet not connected');
                    return null;
                }
                try {
                    const signature = await this.provider.request({
                        method: 'personal_sign',
                        params: [message, this.currentAddress]
                    });
                    return signature;
                } catch (error) {
                    console.error('Error signing message:', error);
                    return null;
                }
            },

            getCurrentWalletAddress() {
                return this.currentAddress;
            },

            getCurrentWalletInfo() {
                if (!this.currentWalletId) return null;
                const wallet = this.discoveredWallets.get(this.currentWalletId);
                return wallet ? {
                    id: this.currentWalletId,
                    name: wallet.info.name,
                    icon: wallet.info.icon
                } : null;
            },

            getAvailableAccounts() {
                return this.availableAccounts || [];
            },

            async disconnectWallet() {
                this.provider = null;
                this.currentAddress = null;
                this.currentWalletId = null;
                this.availableAccounts = [];
                return true;
            },

            async ethCall(to, data, rpcUrl) {
                const normalizedTo = to.startsWith('0x') ? to : '0x' + to;
                const normalizedData = data.startsWith('0x') ? data : '0x' + data;

                if (rpcUrl) {
                    const requestPayload = {
                        jsonrpc: '2.0',
                        method: 'eth_call',
                        params: [{ to: normalizedTo, data: normalizedData }, 'latest'],
                        id: 1
                    };

                    const response = await fetch(rpcUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestPayload)
                    });
                    const result = await response.json();

                    if (result.error) {
                        const errorMsg = result.error.message || 'RPC call failed';
                        const errorData = result.error.data ? ` (data: ${result.error.data})` : '';
                        throw new Error(errorMsg + errorData);
                    }
                    return result.result;
                }

                const provider = this.provider || window.ethereum;
                if (!provider) {
                    throw new Error('No provider available');
                }
                return await provider.request({
                    method: 'eth_call',
                    params: [{ to: normalizedTo, data: normalizedData }, 'latest']
                });
            }
        };

        WalletManager.init();

        const STORAGE_PREFIX = 'polka_';
        const SIGNATURE_EXPIRATION = 7 * 24 * 60 * 60 * 1000; // 7 days

        // Chain verification and switching utilities
        const ChainManager = {
            async getCurrentChainId() {
                const provider = WalletManager.provider || window.ethereum;
                if (!provider) {
                    throw new Error('No wallet provider available');
                }

                try {
                    const chainId = await provider.request({ method: 'eth_chainId' });
                    return chainId;
                } catch (error) {
                    console.error('[ChainManager] Error getting chain ID:', error);
                    throw error;
                }
            },

            async isOnCorrectChain(expectedChainIdHex) {
                try {
                    const currentChainId = await this.getCurrentChainId();
                    const isCorrect = currentChainId.toLowerCase() === expectedChainIdHex.toLowerCase();
                    console.log('[ChainManager] Current chain:', currentChainId, '| Expected:', expectedChainIdHex, '| Match:', isCorrect);
                    return isCorrect;
                } catch (error) {
                    console.error('[ChainManager] Error checking chain:', error);
                    return false;
                }
            },

            async switchToCorrectChain(chainConfigJson) {
                const provider = WalletManager.provider || window.ethereum;
                if (!provider) {
                    throw new Error('No wallet provider available');
                }

                const chainConfig = JSON.parse(chainConfigJson);

                try {
                    console.log('[ChainManager] Attempting to switch to', chainConfig.chainName, '(Chain ID:', chainConfig.chainId + ')');

                    // Try to switch to the chain
                    await provider.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: chainConfig.chainId }]
                    });

                    console.log('[ChainManager] Successfully switched to', chainConfig.chainName);
                    return { success: true, action: 'switched' };

                } catch (switchError) {
                    // Error code 4902 means the chain hasn't been added to the wallet yet
                    if (switchError.code === 4902) {
                        console.log('[ChainManager] Chain not found in wallet, attempting to add it...');

                        try {
                            await provider.request({
                                method: 'wallet_addEthereumChain',
                                params: [chainConfig]
                            });

                            console.log('[ChainManager] Successfully added and switched to', chainConfig.chainName);
                            return { success: true, action: 'added' };

                        } catch (addError) {
                            console.error('[ChainManager] Error adding chain:', addError);
                            throw new Error('Failed to add ' + chainConfig.chainName + ' to wallet: ' + addError.message);
                        }
                    } else {
                        console.error('[ChainManager] Error switching chain:', switchError);
                        throw new Error('Failed to switch to ' + chainConfig.chainName + ': ' + switchError.message);
                    }
                }
            },

            async ensureCorrectChain(expectedChainIdHex, chainConfigJson) {
                const isCorrect = await this.isOnCorrectChain(expectedChainIdHex);

                if (!isCorrect) {
                    console.log('[ChainManager] Wrong chain detected. Prompting user to switch...');
                    return await this.switchToCorrectChain(chainConfigJson);
                }

                console.log('[ChainManager] Already on correct chain');
                return { success: true, action: 'already_correct' };
            }
        };

        const PolkaInterface = {
            hasEthereumProvider() {
                return (typeof window.ethereum !== 'undefined');
            },

            storeSignature(wallet_address, signature) {
                if (typeof wallet_address !== 'string' || typeof signature !== 'string') {
                    console.error('store_signature: Both wallet_address and signature must be strings.');
                    return;
                }

                const key = `${STORAGE_PREFIX}signature_${wallet_address}`;
                const data = {
                    signature: signature,
                    timestamp: Date.now()
                };

                try {
                    localStorage.setItem(key, JSON.stringify(data));
                } catch (e) {
                    console.error('store_signature: Failed to store signature in localStorage.', e);
                }
            },


            storeAuthKey(wallet_address, auth_key) {
                if (typeof wallet_address !== 'string' || typeof auth_key !== 'string') {
                    console.error('store_auth_key: Both wallet_address and auth_key must be strings.');
                    return;
                }

                const key = `${STORAGE_PREFIX}authkey_${wallet_address}`;

                try {
                    localStorage.setItem(key, auth_key);
                } catch (e) {
                    console.error('store_auth_key: Failed to store auth key in localStorage.', e);
                }
            },


            loadSignature(wallet_address) {
                if (typeof wallet_address !== 'string') {
                    console.error('load_signature: wallet_address must be a string.');
                    return '';
                }

                const key = `${STORAGE_PREFIX}signature_${wallet_address}`;

                try {
                    const item = localStorage.getItem(key);
                    if (!item) {
                        return '';
                    }

                    const data = JSON.parse(item);
                    if (!data.signature || !data.timestamp) {
                        localStorage.removeItem(key);
                        return '';
                    }

                    const currentTime = Date.now();
                    if (currentTime - data.timestamp > SIGNATURE_EXPIRATION) {
                        localStorage.removeItem(key);
                        return '';
                    }

                    return data.signature;
                } catch (e) {
                    console.error('load_signature: Failed to load signature from localStorage.', e);
                    return '';
                }
            },


            loadAuthKey(wallet_address) {
                if (typeof wallet_address !== 'string') {
                    console.error('load_auth_key: wallet_address must be a string.');
                    return '';
                }

                const key = `${STORAGE_PREFIX}authkey_${wallet_address}`;

                try {
                    const authKey = localStorage.getItem(key);
                    return authKey ? authKey : '';
                } catch (e) {
                    console.error('load_auth_key: Failed to load auth key from localStorage.', e);
                    return '';
                }
            },

            async connectWallet(walletId = null) {
                return WalletManager.connectWallet(walletId);
            },

            async requestAccountSelection() {
                try {
                    const accounts = await WalletManager.requestAccountSelection();
                    return JSON.stringify(accounts);
                } catch (error) {
                    console.error('Error requesting account selection:', error);
                    return JSON.stringify([]);
                }
            },

            getCurrentWalletAddress() {
                return WalletManager.getCurrentWalletAddress();
            },

            getDiscoveredWallets() {
                return JSON.stringify(WalletManager.getDiscoveredWallets());
            },

            async getAccountsForWallet(walletId) {
                try {
                    const accounts = await WalletManager.getAccountsForWallet(walletId);
                    return JSON.stringify(accounts);
                } catch (error) {
                    console.error('Error getting accounts:', error);
                    return JSON.stringify([]);
                }
            },

            getAvailableAccounts() {
                return JSON.stringify(WalletManager.getAvailableAccounts());
            },

            async selectAccount(address) {
                return WalletManager.selectAccount(address);
            },

            getCurrentWalletInfo() {
                const info = WalletManager.getCurrentWalletInfo();
                return info ? JSON.stringify(info) : null;
            },

            async signMessage(message) {
                return WalletManager.signMessage(message);
            },

            async disconnectWallet() {
                return WalletManager.disconnectWallet();
            },

            isWalletConnected() {
                return (WalletManager.currentAddress != null);
            },

            async queryNFTs(contractAddress, contractABIJson, optionsJson = '{}') {
                try {
                    const options = JSON.parse(optionsJson);
                    
                    if (!contractAddress) {
                        throw new Error('Contract address is required');
                    }

                    const userAddress = options.user_address || WalletManager.currentAddress;
                    if (!userAddress) {
                        throw new Error('User address is required. Either connect wallet or provide user_address in options.');
                    }

                    const result = await this._queryNFTsFromContract(contractAddress, userAddress, options);
                    return JSON.stringify(result);
                } catch (error) {
                    console.error('Error querying NFTs:', error);
                    return JSON.stringify({
                        address: contractAddress,
                        tokenCount: 0,
                        tokens: [],
                        error: error.message
                    });
                }
            },

            async _queryNFTsFromContract(contractAddress, userAddress, options) {
                const tokens = [];
                const fromTokenId = options.from_token_id || 0;
                const toTokenId = options.to_token_id || 10000;
                const batchSize = options.batch_size || 100;

                try {
                    
                    const promises = [];
                    for (let i = fromTokenId; i <= toTokenId; i += batchSize) {
                        const batchPromise = this._queryTokenBatch(contractAddress, userAddress, i, Math.min(i + batchSize - 1, toTokenId), options);
                        promises.push(batchPromise);

                        if (promises.length >= 5) {
                            const batchResults = await Promise.all(promises);
                            batchResults.forEach(batch => tokens.push(...batch));
                            promises.length = 0;
                        }
                    }

                    if (promises.length > 0) {
                        const batchResults = await Promise.all(promises);
                        batchResults.forEach(batch => tokens.push(...batch));
                    }

                    const tokensWithMetadata = await this._fetchTokenMetadata(contractAddress, tokens, options);

                    return {
                        address: contractAddress,
                        tokenCount: tokens.length,
                        tokens: tokensWithMetadata,
                        error: null
                    };
                } catch (error) {
                    throw error;
                }
            },

            async _queryTokenBatch(contractAddress, userAddress, startId, endId, options) {
                const ownedTokens = [];
                const promises = [];
                
                for (let tokenId = startId; tokenId <= endId; tokenId++) {
                    const promise = (async () => {
                        try {
                            const callData = ABIEncoder.buildCallData('ownerOf', ABIEncoder.encodeUint256(tokenId));
                            const rpcUrl = options.rpc_url;
                            const owner = await WalletManager.ethCall(contractAddress, callData, rpcUrl);
                            const ownerAddress = ABIEncoder.decodeAddress(owner);
                            if (ownerAddress && ownerAddress.toLowerCase() === userAddress.toLowerCase()) {
                                ownedTokens.push({ tokenId: tokenId.toString(), owner: ownerAddress });
                            }
                        } catch (e) {
                            // Token doesn't exist, skip
                        }
                    })();
                    promises.push(promise);
                }
                
                await Promise.all(promises);
                return ownedTokens;
            },

            async _fetchTokenMetadata(contractAddress, tokens, options) {
                const tokensWithMetadata = [];
                const metadataPromises = [];
                
                for (const token of tokens) {
                    const promise = this._fetchSingleTokenMetadata(contractAddress, token.tokenId, options)
                        .then(metadata => {
                            tokensWithMetadata.push({
                                ...token,
                                metadata
                            });
                        });
                    metadataPromises.push(promise);
                    
                    if (metadataPromises.length >= 10) {
                        await Promise.all(metadataPromises);
                        metadataPromises.length = 0;
                    }
                }
                
                if (metadataPromises.length > 0) {
                    await Promise.all(metadataPromises);
                }
                
                return tokensWithMetadata;
            },

            async _fetchSingleTokenMetadata(contractAddress, tokenId, options) {
                try {
                    const callData = ABIEncoder.buildCallData('tokenURI', ABIEncoder.encodeUint256(tokenId));
                    const rpcUrl = options.rpc_url;
                    const result = await WalletManager.ethCall(contractAddress, callData, rpcUrl);
                    const tokenURI = ABIEncoder.decodeString(result);
                    
                    if (!tokenURI) {
                        return { tokenId, error: 'No token URI' };
                    }
                    
                    const metadata = await this._fetchMetadataWithCORS(tokenURI, options);
                    return {
                        tokenId,
                        tokenURI,
                        ...metadata
                    };
                } catch (error) {
                    return {
                        tokenId,
                        error: error.message
                    };
                }
            },

            async _fetchMetadataWithCORS(uri, options) {
                let fetchUri = uri;
                if (uri.startsWith('ipfs://')) {
                    const ipfsGateway = options.ipfs_gateway || 'https://ipfs.io/ipfs/';
                    fetchUri = uri.replace('ipfs://', ipfsGateway);
                }
                
                try {
                    const response = await fetch(fetchUri, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                        },
                        mode: 'cors'
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    return await response.json();
                } catch (error) {
                    if (options.corsProxy) {
                        try {
                            const proxyUrl = `${options.corsProxy}${encodeURIComponent(fetchUri)}`;
                            const proxyResponse = await fetch(proxyUrl);
                            if (proxyResponse.ok) {
                                return await proxyResponse.json();
                            }
                        } catch (proxyError) {
                            console.error('CORS proxy also failed:', proxyError);
                        }
                    }
                    
                    return {
                        uri: fetchUri,
                        error: 'Failed to fetch metadata: ' + error.message
                    };
                }
            },

            async equipNFT(tokenId, gameManagerAddress, chainConfigJson) {
                try {
                    const provider = WalletManager.provider || window.ethereum;
                    if (!provider) {
                        throw new Error('No wallet connected');
                    }

                    if (!WalletManager.currentAddress) {
                        throw new Error('No wallet address available');
                    }

                    const chainConfig = JSON.parse(chainConfigJson);

                    // Ensure wallet is on the correct chain before transaction
                    const chainResult = await ChainManager.ensureCorrectChain(chainConfig.chainId, chainConfigJson);

                    if (!chainResult.success) {
                        throw new Error('Failed to switch to ' + chainConfig.chainName + ' network');
                    }

                    console.log('[PolkaInterface] Equipping NFT #' + tokenId);

                    // Encode the function call for equipHat(tokenId)
                    const selector = '0x20210749'; // equipHat(uint256) function selector
                    const encodedTokenId = ABIEncoder.encodeUint256(tokenId);
                    const data = selector + encodedTokenId;

                    // Send transaction
                    const txHash = await provider.request({
                        method: 'eth_sendTransaction',
                        params: [{
                            from: WalletManager.currentAddress,
                            to: gameManagerAddress,
                            data: data
                        }]
                    });

                    console.log('[PolkaInterface] Equip transaction sent:', txHash);

                    // Wait for transaction receipt
                    const res = await this._waitForTransaction(provider, txHash);
                    console.log(res);
                    console.log('[PolkaInterface] NFT #' + tokenId + ' equipped successfully');
                    return JSON.stringify({ success: true, tokenId: tokenId, txHash: txHash });

                } catch (error) {
                    console.error('[PolkaInterface] Error equipping NFT:', error);
                    return JSON.stringify({ success: false, error: error.message || 'Transaction failed' });
                }
            },

            async unequipNFT(gameManagerAddress, chainConfigJson) {
                try {
                    const provider = WalletManager.provider || window.ethereum;
                    if (!provider) {
                        throw new Error('No wallet connected');
                    }

                    if (!WalletManager.currentAddress) {
                        throw new Error('No wallet address available');
                    }

                    const chainConfig = JSON.parse(chainConfigJson);

                    // Ensure wallet is on the correct chain before transaction
                    const chainResult = await ChainManager.ensureCorrectChain(chainConfig.chainId, chainConfigJson);

                    if (!chainResult.success) {
                        throw new Error('Failed to switch to ' + chainConfig.chainName + ' network');
                    }

                    console.log('[PolkaInterface] Unequipping NFT');

                    // Encode the function call for unequipHat()
                    const selector = '0x9871bf3c'; // unequipHat() function selector
                    const data = selector;

                    // Send transaction
                    const txHash = await provider.request({
                        method: 'eth_sendTransaction',
                        params: [{
                            from: WalletManager.currentAddress,
                            to: gameManagerAddress,
                            data: data
                        }]
                    });

                    console.log('[PolkaInterface] Unequip transaction sent:', txHash);

                    // Wait for transaction receipt
                    await this._waitForTransaction(provider, txHash);

                    console.log('[PolkaInterface] NFT unequipped successfully');
                    return JSON.stringify({ success: true, tokenId: 0, txHash: txHash });

                } catch (error) {
                    console.error('[PolkaInterface] Error unequipping NFT:', error);
                    return JSON.stringify({ success: false, error: error.message || 'Transaction failed' });
                }
            },

            async queryEquippedNFT(playerAddress, gameManagerAddress, rpcUrl) {
                try {
                    console.log('[PolkaInterface] Querying equipped NFT for:', playerAddress);

                    // Encode the function call for getEquippedHat(address)
                    const selector = '0x018e8b41'; // getEquippedHat(address) function selector
                    const encodedAddress = ABIEncoder.encodeAddress(playerAddress);
                    const data = selector + encodedAddress;

                    // Use RPC URL for read-only call
                    const result = await WalletManager.ethCall(gameManagerAddress, data, rpcUrl);

                    // Decode the result (uint256)
                    const equippedTokenId = ABIEncoder.decodeUint256(result);

                    console.log('[PolkaInterface] Player has equipped NFT #' + equippedTokenId);
                    return equippedTokenId;

                } catch (error) {
                    console.error('[PolkaInterface] Error querying equipped NFT:', error);
                    throw error;
                }
            },

            async _waitForTransaction(provider, txHash, maxAttempts = 30) {
                for (let i = 0; i < maxAttempts; i++) {
                    try {
                        const receipt = await provider.request({
                            method: 'eth_getTransactionReceipt',
                            params: [txHash]
                        });

                        if (receipt && receipt.blockNumber) {
                            if (receipt.status === '0x1' || receipt.status === 1) {
                                console.log('[PolkaInterface] Transaction confirmed:', txHash);
                                return receipt;
                            } else {
                                throw new Error('Transaction failed');
                            }
                        }
                    } catch (error) {
                        if (i === maxAttempts - 1) {
                            throw error;
                        }
                    }

                    // Wait 1 second before checking again
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }

                throw new Error('Transaction timeout - receipt not found after ' + maxAttempts + ' attempts');
            }
        };

        window.PolkaInterface = PolkaInterface;

        </script>
    </body>
</html>